<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[tsconfig.json 配置详解]]></title>
    <url>%2F2019%2F08%2F05%2Ftsconfig-json-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[因为工作中用到了 typescript，抽时间，先大致介绍一下 tsconfig 配置文件，完整的 ts 学习还是建议从官方教程出发，玩儿的愉快 tsconfig.json 配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&#123; "compilerOptions": &#123; /* Basic Options */ "target": "es5" /* target用于指定编译之后的版本目标: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019' or 'ESNEXT'. */, "module": "commonjs" /* 用来指定要使用的模块标准: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */, "lib": ["es6", "dom"] /* lib用于指定要包含在编译中的库文件 */, "allowJs": true, /* allowJs设置的值为true或false，用来指定是否允许编译js文件，默认是false，即不编译js文件 */ "checkJs": true, /* checkJs的值为true或false，用来指定是否检查和报告js文件中的错误，默认是false */ "jsx": "preserve", /* 指定jsx代码用于的开发环境: 'preserve', 'react-native', or 'react'. */ "declaration": true, /* declaration的值为true或false，用来指定是否在编译的时候生成相应的".d.ts"声明文件。如果设为true，编译每个ts文件之后会生成一个js文件和一个声明文件。但是declaration和allowJs不能同时设为true */ "declarationMap": true, /* 值为true或false，指定是否为声明文件.d.ts生成map文件 */ "sourceMap": true, /* sourceMap的值为true或false，用来指定编译时是否生成.map文件 */ "outFile": "./", /* outFile用于指定将输出文件合并为一个文件，它的值为一个文件路径名。比如设置为"./dist/main.js"，则输出的文件为一个main.js文件。但是要注意，只有设置module的值为amd和system模块时才支持这个配置 */ "outDir": "./", /* outDir用来指定输出文件夹，值为一个文件夹路径字符串，输出的文件都将放置在这个文件夹 */ "rootDir": "./", /* 用来指定编译文件的根目录，编译器会在根目录查找入口文件，如果编译器发现以rootDir的值作为根目录查找入口文件并不会把所有文件加载进去的话会报错，但是不会停止编译 */ "composite": true, /* 是否编译构建引用项目 */ "incremental": true, /* Enable incremental compilation */ "tsBuildInfoFile": "./", /* Specify file to store incremental compilation information */ "removeComments": true, /* removeComments的值为true或false，用于指定是否将编译后的文件中的注释删掉，设为true的话即删掉注释，默认为false */ "noEmit": true, /* 不生成编译文件，这个一般比较少用 */ "importHelpers": true, /* importHelpers的值为true或false，指定是否引入tslib里的辅助工具函数，默认为false */ "downlevelIteration": true, /* 当target为'ES5' or 'ES3'时，为'for-of', spread, and destructuring'中的迭代器提供完全支持 */ "isolatedModules": true, /* isolatedModules的值为true或false，指定是否将每个文件作为单独的模块，默认为true，它不可以和declaration同时设定 */ /* Strict Type-Checking Options */ "strict": true /* strict的值为true或false，用于指定是否启动所有类型检查，如果设为true则会同时开启下面这几个严格类型检查，默认为false */, "noImplicitAny": true, /* noImplicitAny的值为true或false，如果我们没有为一些值设置明确的类型，编译器会默认认为这个值为any，如果noImplicitAny的值为true的话。则没有明确的类型会报错。默认值为false */ "strictNullChecks": true, /* strictNullChecks为true时，null和undefined值不能赋给非这两种类型的值，别的类型也不能赋给他们，除了any类型。还有个例外就是undefined可以赋值给void类型 */ "strictFunctionTypes": true, /* strictFunctionTypes的值为true或false，用于指定是否使用函数参数双向协变检查 */ "strictBindCallApply": true, /* 设为true后会对bind、call和apply绑定的方法的参数的检测是严格检测的 */ "strictPropertyInitialization": true, /* 设为true后会检查类的非undefined属性是否已经在构造函数里初始化，如果要开启这项，需要同时开启strictNullChecks，默认为false */ "noImplicitThis": true, /* 当this表达式的值为any类型的时候，生成一个错误 */ "alwaysStrict": true, /* alwaysStrict的值为true或false，指定始终以严格模式检查每个模块，并且在编译之后的js文件中加入"use strict"字符串，用来告诉浏览器该js为严格模式 */ /* Additional Checks */ "noUnusedLocals": true, /* 用于检查是否有定义了但是没有使用的变量，对于这一点的检测，使用eslint可以在你书写代码的时候做提示，你可以配合使用。它的默认值为false */ "noUnusedParameters": true, /* 用于检查是否有在函数体中没有使用的参数，这个也可以配合eslint来做检查，默认为false */ "noImplicitReturns": true, /* 用于检查函数是否有返回值，设为true后，如果函数没有返回值则会提示，默认为false */ "noFallthroughCasesInSwitch": true, /* 用于检查switch中是否有case没有使用break跳出switch，默认为false */ /* Module Resolution Options */ "moduleResolution": "node", /* 用于选择模块解析策略，有'node'和'classic'两种类型' */ "baseUrl": "./", /* baseUrl用于设置解析非相对模块名称的基本目录，相对模块不会受baseUrl的影响 */ "paths": &#123;&#125;, /* 用于设置模块名称到基于baseUrl的路径映射 */ "rootDirs": [], /* rootDirs可以指定一个路径列表，在构建时编译器会将这个路径列表中的路径的内容都放到一个文件夹中 */ "typeRoots": [], /* typeRoots用来指定声明文件或文件夹的路径列表，如果指定了此项，则只有在这里列出的声明文件才会被加载 */ "types": [], /* types用来指定需要包含的模块，只有在这里列出的模块的声明文件才会被加载进来 */ "allowSyntheticDefaultImports": true, /* 用来指定允许从没有默认导出的模块中默认导入 */ "esModuleInterop": true /* 通过为导入内容创建命名空间，实现CommonJS和ES模块之间的互操作性 */, "preserveSymlinks": true, /* 不把符号链接解析为其真实路径，具体可以了解下webpack和nodejs的symlink相关知识 */ /* Source Map Options */ "sourceRoot": "", /* sourceRoot用于指定调试器应该找到TypeScript文件而不是源文件位置，这个值会被写进.map文件里 */ "mapRoot": "", /* mapRoot用于指定调试器找到映射文件而非生成文件的位置，指定map文件的根路径，该选项会影响.map文件中的sources属性 */ "inlineSourceMap": true, /* 指定是否将map文件的内容和js文件编译在同一个js文件中，如果设为true，则map的内容会以//# sourceMappingURL=然后拼接base64字符串的形式插入在js文件底部 */ "inlineSources": true, /* 用于指定是否进一步将.ts文件的内容也包含到输入文件中 */ /* Experimental Options */ "experimentalDecorators": true /* 用于指定是否启用实验性的装饰器特性 */ "emitDecoratorMetadata": true, /* 用于指定是否为装饰器提供元数据支持，关于元数据，也是ES6的新标准，可以通过Reflect提供的静态方法获取元数据，如果需要使用Reflect的一些方法，需要引入ES2015.Reflect这个库 */ &#125; "files": [], // files可以配置一个数组列表，里面包含指定文件的相对或绝对路径，编译器在编译的时候只会编译包含在files中列出的文件，如果不指定，则取决于有没有设置include选项，如果没有include选项，则默认会编译根目录以及所有子目录中的文件。这里列出的路径必须是指定文件，而不是某个文件夹，而且不能使用* ? **/ 等通配符 "include": [], // include也可以指定要编译的路径列表，但是和files的区别在于，这里的路径可以是文件夹，也可以是文件，可以使用相对和绝对路径，而且可以使用通配符，比如"./src"即表示要编译src文件夹下的所有文件以及子文件夹的文件 "exclude": [], // exclude表示要排除的、不编译的文件，它也可以指定一个列表，规则和include一样，可以是文件或文件夹，可以是相对路径或绝对路径，可以使用通配符 "extends": "", // extends可以通过指定一个其他的tsconfig.json文件路径，来继承这个配置文件里的配置，继承来的文件的配置会覆盖当前文件定义的配置。TS在3.2版本开始，支持继承一个来自Node.js包的tsconfig.json配置文件 "compileOnSave": true, // compileOnSave的值是true或false，如果设为true，在我们编辑了项目中的文件保存的时候，编辑器会根据tsconfig.json中的配置重新生成文件，不过这个要编辑器支持 "references": [], // 一个对象数组，指定要引用的项目&#125;]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4打造极致开发环境]]></title>
    <url>%2F2019%2F08%2F05%2Fwebpack4%E6%89%93%E9%80%A0%E6%9E%81%E8%87%B4%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 webpack已经是大部分前端项目打包工具的首选，grunt、glup、browserify等逐渐沦为辅助甚至完全被替代。在grunt、glup、browserify等已经相当火了之后，webpack长江后浪推前浪，把前辈们拍死在沙滩上，实力惊人。 本文主要从webpack4.x入手，会对平时常用的Webpack配置一一讲解，各个功能点都有对应的详细例子，所以本文也比较长，但如果你能动手跟着本文中的例子完整写一次，相信你会觉得Webpack也不过如此。 安装webpack的几种方式 global(全局):通过webpack index.js运行 local(项目维度安装):通过npx webpack index.js运行 知识点总结 避免全局安装webpack（针对多个项目采用不同的webpack版本进行打包的场景），可采用npx，具体可参考http://www.ruanyifeng.com/blog/2019/02/npx.html npx webpack --config 配置文件名可指定webpack配置文件（默认为webpack.config.js） mode选项(可能的值为none、development或production(默认值))配置用于提供模式配置选项告诉webpack相应的使用其内置的优化。具体可参考https://webpack.js.org/configuration/mode/#root npm scripts:通过配置package.json里面的scripts字段，直接运行webpack即可。等价于yarn run bundle -&gt; webpack file-loader可打包处理eot|svg|ttf|woff等字体文件 entry(入口)单一入口1234567// webpack.config.jsconst config = &#123; entry: &#123; main: './src/index.js' &#125;&#125;; 多入口12345678// webpack.config.jsconst config = &#123; entry: &#123; main: './src/index.js', sub: './src/sub.js' &#125;&#125;; output(输出)默认配置123456789101112// webpack.config.jsconst path = require('path');...const config = &#123; output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;;module.exports = config; 多个入口起点 如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。1234567891011121314// webpack.config.jsconst path = require('path');&#123; entry: &#123; main: './src/index.js', sub: './src/sub.js' &#125;, output: &#123; filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125;// 写入到硬盘：./dist/main.js, ./dist/sub.js 高级进阶 使用cdn123456789101112131415// webpack.config.jsconst path = require('path');&#123; entry: &#123; main: './src/index.js', sub: './src/sub.js' &#125;, output: &#123; publicPath: 'http://cdn.example.com' filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125;// 写入到http://cdn.example.com/main.js, http://cdn.example.com/sub.js loaders webpack 可以使用 loader 来预处理文件。这允许你打包除 JavaScript 之外的任何静态资源。 file-loader file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。 默认情况下，生成的文件的文件名就是文件内容的 MD5 哈希值并会保留所引用资源的原始扩展名。12345678910rules: [&#123; test: /\.(jpg|png|gif)$/, use: &#123; loader: 'file-loader', options: &#123; name: '[name]_[hash].[ext]', outputPath: 'images/', &#125; &#125;&#125;] url-loader url-loader 功能类似于 file-loader，但是在文件大小（单位 byte）低于指定的限制时，可以返回一个 DataURL。 url-loader把资源文件转换为URL，file-loader也是一样的功能。不同之处在于url-loader更加灵活，它可以把小文件转换为base64格式的URL，从而减少网络请求次数。url-loader依赖file-loader。1234567891011rules: [&#123; test: /\.(jpg|png|gif)$/, use: &#123; loader: 'url-loader', options: &#123; name: '[name]_[hash].[ext]', outputPath: 'images/', limit: 204800 &#125; &#125;&#125;] css-loader 只负责加载css模块,不会将加载的css样式应用到html importLoaders用于指定在 css-loader 前应用的 loader 的数量 查询参数 modules 会启用 CSS 模块规范12345678module: &#123; rules: [ &#123; test: /\.css$/, use: [ 'style-loader', 'css-loader' ] &#125; ]&#125; style-loader 负责将css-loader加载到的css样式动态的添加到html-head-style标签中 一般建议将 style-loader 与 css-loader 结合使用 sass-loader安装yarn add sass-loader node-sass webpack --dev node-sass 和 webpack 是 sass-loader 的 peerDependency，因此能够精确控制它们的版本。 loader执行顺序：从下至上，从右至左 通过将 style-loader 和 css-loader 与 sass-loader 链式调用，可以立刻将样式作用在 DOM 元素。12345678910111213141516// webpack.config.jsmodule.exports = &#123;...module: &#123; rules: [&#123; test: /\.scss$/, use: [&#123; loader: "style-loader" // 将 JS 字符串生成为 style 节点 &#125;, &#123; loader: "css-loader" // 将 CSS 转化成 CommonJS 模块 &#125;, &#123; loader: "sass-loader" // 将 Sass 编译成 CSS &#125;] &#125;]&#125;&#125;; postcss-loader webpack4中使用postcss-loader代替autoprefixer，给css3样式加浏览器前缀。具体可参考https://blog.csdn.net/u014628388/article/details/825931851234567891011121314151617// webpack.config.js &#123; test: /\.scss$/, use: [ 'style-loader', 'css-loader', 'sass-loader', 'postcss-loader' ],&#125;//postcss.config.jsmodule.exports = &#123; plugins: [ require('autoprefixer')(&#123; browsers: ['last 2 versions'] &#125;), ],&#125;; plugins plugin可以在webpack运行到某个时刻的时候，帮你做一些事情 HtmlWebpackPlugin HtmlWebpackPlugin会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中12345678910const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123;...plugins: [ new HtmlWebpackPlugin(&#123; template: 'src/index.html' &#125;), ],&#125;; clean-webpack-plugin clean-webpack-plugin插件用来清除残留打包文件，特别是文件末尾添加了hash之后，会导致改变文件内容后重新打包时，文件名不同而内容越来越多。 新版本中的clean-webpack-plugin仅接受一个对象，默认不需要传任何参数。具体可参考https://blog.csdn.net/qq_23521659/article/details/883537081234567891011const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');module.exports = &#123;...plugins: [ new CleanWebpackPlugin() ], output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125; SplitChunksPlugin 具体概念可参考https://juejin.im/post/5af15e895188256715479a9a 1234567891011121314151617181920splitChunks: &#123; chunks: "async", minSize: 30000, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\/]node_modules[\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125;&#125; MiniCssExtractPlugin 将CSS提取为独立的文件的插件，对每个包含css的js文件都会创建一个CSS文件，支持按需加载css和sourceMap123456789101112131415161718192021222324252627282930313233343536373839404142const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = &#123; plugins: [ new MiniCssExtractPlugin(&#123; // Options similar to the same options in webpackOptions.output // both options are optional filename: '[name].css', chunkFilename: '[id].css', &#125;), ], module: &#123; rules: [ &#123; test: /\.scss$/, use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, &#123; loader: "css-loader", options: &#123; importLoaders: 2 // 用于指定在 css-loader 前应用的 loader 的数量 // modules: true // 查询参数 modules 会启用 CSS 模块规范 &#125; &#125;, "sass-loader", "postcss-loader" ] &#125;, &#123; test: /\.css$/, use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, "css-loader", "postcss-loader" ] &#125; ], &#125;,&#125;; OptimizeCSSAssetsPlugin webpack5可能会内置CSS 压缩器，webpack4需要自己使用压缩器，可以使用 optimize-css-assets-webpack-plugin 插件。 设置 optimization.minimizer 覆盖webpack默认提供的，确保也指定一个JS压缩器123456789101112131415161718192021222324252627282930313233const UglifyJsPlugin = require('uglifyjs-webpack-plugin');const MiniCssExtractPlugin = require('mini-css-extract-plugin');const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');module.exports = &#123; optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, parallel: true, sourcMap: true &#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;), ], &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: "[name].css", chunkFilename: "[id].css" &#125;), ], module: &#123; rules: [ &#123; test: /\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader' ] &#125; ] &#125;&#125; devtoolsource map source map就是对打包生成的代码与源代码的一种映射，主要是为了方便定位问题和排查问题。devtool关键有eval、cheap、module、inline和source-map这几块，具体可参考文档：https://www.webpackjs.com/configuration/devtool/ development环境参考配置: &#39;cheap-module-eval-source-map&#39; production环境参考配置: &#39;cheap-module-source-map&#39; webpack-dev-server webpack-dev-server提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)。具体可参考https://www.webpackjs.com/guides/development/#%E4%BD%BF%E7%94%A8-webpack-dev-server 接口代理(请求转发) 如果你有单独的后端开发服务器 API，并且希望在同域名下发送 API 请求 ，那么代理某些 URL 会很有用。dev-server 使用了非常强大的 http-proxy-middleware 包。常用于接口请求转发。具体参考https://www.webpackjs.com/configuration/dev-server/#devserver-proxy12345678910111213141516171819devServer: &#123; contentBase: "./dist", open: true, hot: true, hotOnly: true, proxy: &#123; "/api": &#123; target: "https://other-server.example.com", pathRewrite: &#123;"^/api" : ""&#125;, secure: false, bypass: function(req, res, proxyOptions) &#123; if (req.headers.accept.indexOf("html") !== -1) &#123; console.log("Skipping proxy for browser request."); return "/index.html"; &#125; &#125; &#125; &#125; &#125;, 解决单页面路由问题 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html通过传入以下启用：1historyApiFallback: true 通过传入一个对象，比如使用 rewrites 这个选项，此行为可进一步地控制：1234567historyApiFallback: &#123; rewrites: [ &#123; from: /^\/$/, to: '/views/landing.html' &#125;, &#123; from: /^\/subpage/, to: '/views/subpage.html' &#125;, &#123; from: /./, to: '/views/404.html' &#125; ]&#125; webpack-dev-middleware webpack-dev-middleware 是一个容器(wrapper)，它可以把 webpack 处理后的文件传递给一个服务器(server)。 webpack-dev-server 在内部使用了它，同时，它也可以作为一个单独的包来使用，以便进行更多自定义设置来实现更多的需求123456789101112131415161718// server.js// 使用webpack-dev-middleware// https://www.webpackjs.com/guides/development/#%E4%BD%BF%E7%94%A8-webpack-dev-middlewareconst express = require('express');const webpack = require('webpack');const webpackDevMiddleware = require('webpack-dev-middleware');const config = require('./webpack.config.js');const complier = webpack(config);const app = express();app.use(webpackDevMiddleware(complier, &#123; publicPath: config.output.publicPath&#125;))app.listen(3000, () =&gt; &#123; console.log('server is running');&#125;) Hot Module Replacement 模块热替换(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新。1234567891011121314// webpack.config.js...const webpack = require('webpack');...devServer: &#123; contentBase: './dist', open: true, hot: true, hotOnly: true&#125;,plugins: [ ... new webpack.HotModuleReplacementPlugin()], 如果已经通过 HotModuleReplacementPlugin 启用了模块热替换(Hot Module Replacement)，则它的接口将被暴露在 module.hot 属性下面。通常，用户先要检查这个接口是否可访问，然后再开始使用它。123456// index.jsif (module.hot) &#123; module.hot.accept('./library.js', function() &#123; // 使用更新过的 library 模块执行某些操作... &#125;)&#125; bundle 分析 借助一些官方推荐的可视化分析工具，可对打包后的模块进行分析以及优化 webpack-chart: webpack 数据交互饼图 webpack-visualizer: 可视化并分析你的 bundle，检查哪些模块占用空间，哪些可能是重复使用的 webpack-bundle-analyzer: 一款分析 bundle 内容的插件及 CLI 工具，以便捷的、交互式、可缩放的树状图形式展现给用户 Preloading、Prefetching prefetch：会等待核心代码加载完成后，页面带宽空闲后再去加载prefectch对应的文件;preload：和主文件一起去加载 可以使用谷歌浏览器Coverage工具查看代码覆盖率(ctrl+shift+p &gt; show coverage) 使用异步引入js的方式可以提高js的使用率，所以webpack建议我们多使用异步引入的方式，这也是splitChunks.chunks的默认值是”async”的原因 使用魔法注释 / webpackPrefetch: true / ，这样在主要js加载完，带宽有空闲时，会自动下载需要引入的js 使用魔法注释 / webpackPreload: true /，区别是webpackPrefetch会等到主业务文件加载完，带宽有空闲时再去下载js，而preload是和主业务文件一起加载的 babelbabel编译es6、jsx等 @babel/core babel核心模块 @babel-preset-env 编译es6等 @babel/preset-react 转换jsx @babel/plugin-transform-runtime 避免polyfill污染全局变量，减少打包体积 @babel/polyfill es6内置方法和函数转化垫片 @babel/runtime1234567891011module: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', &#125; &#125; ]&#125; 新建.babelrc文件1234&#123; "presets": ["@babel/preset-env", "@babel/preset-react"], "plugins": ["@babel/plugin-transform-runtime"]&#125; 按需引入polyfill在src下的index.js中全局引入@babel/polyfill并写入es6语法，但是这样有一个缺点:全局引入@babel/polyfill的这种方式可能会导入代码中不需要的polyfill，从而使打包体积更大，修改.babelrc配置1234567891011121314`yarn add core-js@2 @babel/runtime-corejs2 --dev`&#123; "presets": [ [ "@babel/preset-env", &#123; "useBuiltIns": "usage" &#125; ], "@babel/preset-react" ], "plugins": ["@babel/plugin-transform-runtime"]&#125; 这就配置好了按需引入。配置了按需引入polyfill后，用到es6以上的函数，babel会自动导入相关的polyfill，这样能大大减少打包编译后的体积。 babel-runtime和babel-polyfill的区别 参考https://www.jianshu.com/p/73ba084795ce babel-polyfill会”加载整个polyfill库”，针对编译的代码中新的API进行处理，并且在代码中插入一些帮助函数 babel-polyfill解决了Babel不转换新API的问题，但是直接在代码中插入帮助函数，会导致污染了全局环境，并且不同的代码文件中包含重复的代码，导致编译后的代码体积变大。 Babel为了解决这个问题，提供了单独的包babel-runtime用以提供编译模块的工具函数， 启用插件babel-plugin-transform-runtime后，Babel就会使用babel-runtime下的工具函数 babel-runtime适合在组件，类库项目中使用，而babel-polyfill适合在业务项目中使用。 高级概念tree shaking(js) tree shaking可清除代码中无用的js代码，只支持import方式引入，不支持commonjs的方式引入mode是production的无需配置，下面的配置是针对development的12345678// webpack.config.jsoptimization: &#123; usedExports: true&#125;// package.json"sideEffects": false, Code Spliting 代码分割，和webpack无关 同步代码(需在webpack.config.js中配置optimization)1234567891011// index.jsimport _ from 'lodash';console.log(_.join(['a','b','c'], '****'))// 在webpack.base.js里做相关配置optimization: &#123; splitChunks: &#123; chunks: 'all' &#125; &#125;, 异步代码(无需任何配置，但需安装@babel/plugin-syntax-dynamic-import包)123456789101112// index.jsfunction getComponent() &#123; return import('lodash').then((&#123; default: _ &#125;) =&gt; &#123; const element = document.createElement('div'); element.innerHTML = _.join(['Jack', 'Cool'], '-'); return element; &#125;)&#125;getComponent().then(el =&gt; &#123; document.body.appendChild(el);&#125;) Caching(缓存) 通过使用 output.filename 进行文件名替换，可以确保浏览器获取到修改后的文件。[hash] 替换可以用于在文件名中包含一个构建相关(build-specific)的 hash，但是更好的方式是使用 [contenthash] 替换，当文件内容发生变化时，[contenthash]也会发生变化1234output: &#123; filename: "[name].[contenthash].js", chunkFilename: '[name].[contenthash].chunk.js'&#125; Shimming webpack 编译器(compiler)能够识别遵循 ES2015 模块语法、CommonJS 或 AMD 规范编写的模块。然而，一些第三方的库(library)可能会引用一些全局依赖（例如 jQuery 中的 $）。这些库也可能创建一些需要被导出的全局变量。这些“不符合规范的模块”就是 shimming 发挥作用的地方 shimming 全局变量(第三方库)(ProvidePlugin相当于一个垫片)12345678910111213141516 const path = require('path');+ const webpack = require('webpack'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist')- &#125;+ &#125;,+ plugins: [+ new webpack.ProvidePlugin(&#123;+ _: 'lodash'+ &#125;)+ ] &#125;; 细粒度 shimming(this指向window)(需要安装imports-loader依赖)1234567891011121314151617181920212223 const path = require('path'); const webpack = require('webpack'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;,+ module: &#123;+ rules: [+ &#123;+ test: require.resolve('index.js'),+ use: 'imports-loader?this=&gt;window'+ &#125;+ ]+ &#125;, plugins: [ new webpack.ProvidePlugin(&#123; join: ['lodash', 'join'] &#125;) ] &#125;; 环境变量 webpack命令行环境选项 –env允许您传入任意数量的环境变量。您的环境变量将可访问webpack.config.js。例如，–env.production或–env.NODE_ENV=local1webpack --env.NODE_ENV=local --env.production --progress 使用环境变量必须对webpack配置进行一项更改。通常，module.exports指向配置对象。要使用该env变量，必须转换module.exports为函数：12345678910111213141516// webpack.config.jsconst path = require('path');module.exports = env =&gt; &#123; // Use env.&lt;YOUR VARIABLE&gt; here: console.log('NODE_ENV: ', env.NODE_ENV); // 'local' console.log('Production: ', env.production); // true return &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125; &#125;;&#125;; library 打包配置 除了打包应用程序代码，webpack 还可以用于打包 JavaScript library用户应该能够通过以下方式访问library: ES2015 模块。例如 import library from ‘library’ CommonJS 模块。例如 require(‘library’) 全局变量，当通过 script 脚本引入时 我们打包的library中可能会用到一些第三方库，诸如lodash。现在，如果执行 webpack，你会发现创建了一个非常巨大的文件。如果你查看这个文件，会看到 lodash 也被打包到代码中。在这种场景中，我们更倾向于把 lodash 当作 peerDependency。也就是说，用户应该已经将 lodash 安装好。因此，你可以放弃对外部 library 的控制，而是将控制权让给使用 library 的用户。这可以使用 externals 配置来完成：12345678910111213141516171819 // webpack.config.js var path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'webpack-numbers.js'- &#125;+ &#125;,+ externals: &#123;+ lodash: &#123;+ commonjs: 'lodash',+ commonjs2: 'lodash',+ amd: 'lodash',+ root: '_'+ &#125;+ &#125; &#125;; 对于用途广泛的 library，我们希望它能够兼容不同的环境，例如 CommonJS，AMD，Node.js 或者作为一个全局变量。为了让你的 library 能够在各种用户环境(consumption)中可用，需要在 output 中添加 library 属性：1234567891011121314151617181920 // webpack.config.js var path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'),- filename: 'library.js'+ filename: 'library.js',+ library: 'library' &#125;, externals: &#123; lodash: &#123; commonjs: 'lodash', commonjs2: 'lodash', amd: 'lodash', root: '_' &#125; &#125; &#125;; 当你在 import 引入模块时，这可以将你的 library bundle 暴露为名为 webpackNumbers 的全局变量。为了让 library 和其他环境兼容，还需要在配置文件中添加 libraryTarget 属性。这是可以控制 library 如何以不同方式暴露的选项。12345678910111213141516171819 var path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'library.js',+ library: 'library',+ libraryTarget: 'umd' &#125;, externals: &#123; lodash: &#123; commonjs: 'lodash', commonjs2: 'lodash', amd: 'lodash', root: '_' &#125; &#125; &#125;; 我们还需要通过设置 package.json 中的 main 字段，添加生成 bundle 的文件路径。123456// package.json&#123; ... "main": "dist/library.js", ...&#125; PWA 打包配置 渐进式网络应用程序(Progressive Web Application - PWA)，是一种可以提供类似于原生应用程序(native app)体验的网络应用程序(web app)。PWA 可以用来做很多事。其中最重要的是，在离线(offline)时应用程序能够继续运行功能。这是通过使用名为 Service Workers 的网络技术来实现的添加 workbox-webpack-plugin 插件，并调整 webpack.config.js 文件：1npm install workbox-webpack-plugin --save-dev webpack.config.js1234567891011121314151617181920212223242526272829 const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin');+ const WorkboxPlugin = require('workbox-webpack-plugin'); module.exports = &#123; entry: &#123; app: './src/index.js', print: './src/print.js' &#125;, plugins: [ new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin(&#123;- title: 'Output Management'+ title: 'Progressive Web Application'- &#125;)+ &#125;),+ new WorkboxPlugin.GenerateSW(&#123;+ // 这些选项帮助 ServiceWorkers 快速启用+ // 不允许遗留任何“旧的” ServiceWorkers+ clientsClaim: true,+ skipWaiting: true+ &#125;) ], output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist') &#125; &#125;; 注册Service Worker123456789101112 import _ from 'lodash'; import printMe from './print.js';+ if ('serviceWorker' in navigator) &#123;+ window.addEventListener('load', () =&gt; &#123;+ navigator.serviceWorker.register('/sw.js').then(registration =&gt; &#123;+ console.log('SW registered: ', registration);+ &#125;).catch(registrationError =&gt; &#123;+ console.log('SW registration failed: ', registrationError);+ &#125;);+ &#125;);+ &#125; 现在来进行测试。停止服务器并刷新页面。如果浏览器能够支持 Service Worker，你应该可以看到你的应用程序还在正常运行。然而，服务器已经停止了服务，此刻是 Service Worker 在提供服务。 TypeScript 打包配置 可参考https://www.webpackjs.com/guides/typescript/或https://webpack.js.org/guides/typescript/ 安装ts依赖npm install --save-dev typescript ts-loader 增加tsconfig.json配置文件12345678910&#123; "compilerOptions": &#123; "outDir": "./dist/", "noImplicitAny": true, "module": "es6", "target": "es5", "jsx": "react", "allowJs": true &#125;&#125; webpack.config.js添加对ts/tsx语法支持(ts-loader) 123456789101112131415161718192021const path = require('path');module.exports = &#123; entry: './src/index.ts', module: &#123; rules: [ &#123; test: /\.tsx?$/, use: 'ts-loader', exclude: /node_modules/ &#125; ] &#125;, resolve: &#123; extensions: [ '.tsx', '.ts', '.js' ] &#125;, output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;; 当从 npm 安装第三方库时，一定要牢记同时安装这个库的类型声明文件。可以从 TypeSearch 中找到并安装这些第三方库的类型声明文件。如npm install --save-dev @types/lodash webpack性能优化 及时更新node、yarn、webpack等的版本 在尽可能少的模块上应用loader plugin尽可能精简并确保可靠(选用社区已验证的插件) resolve参数合理配置(具体参考https://www.webpackjs.com/configuration/resolve/) 使用DllPlugin提高打包速度 控制包文件大小(tree shaking / splitChunksPlugin) thread-loader,parallel-webpack,happypack多进程打包 合理利用sourceMap 结合stats.json分析打包结果(bundle analyze) 开发环境内存编译 开发环境无用插件剔除]]></content>
      <categories>
        <category>web工程化</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native开发过程梳理]]></title>
    <url>%2F2019%2F08%2F04%2Freact-native%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[之前在用 rn 开发跨平台应用时，仅是开发环境配置（运行基础的 hello world），就耗费了我大量的时间，今天整理一下，希望给打算入 rn 神坑的小伙伴一个指引（我已弃坑，准备去搞 flutter 了）。以下是 windows 平台的，mac 平台请绕路。。 环境配置 配置可参考https://reactnative.cn/docs/0.40/getting-started.html https://reactnative.cn/docs/getting-started.html https://facebook.github.io/react-native/docs/getting-started 1、下载Chocolatey(windows 包管理器)，用于安装python2、jdk8、node。安装方式 1@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin jdk 安装与环境变量配置: https://jingyan.baidu.com/article/6dad5075d1dc40a123e36ea3.html 2、设置 npm 镜像 12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global 3、安装 React Native 的命令行工具（react-native-cli） 1npm install -g react-native-cli 4、 android studio 安装(下载地址: https://developer.android.google.cn/)安装界面中选择“custom”选项，确保选中了以下几项: Android SDK Android SDK Platform Performance (Intel ® HAXM) Android Virtual Device 5、ANDROID_HOME 环境变量配置 6、将 Android SDK 的 Tools 目录添加到 PATH 变量中可以把 Android SDK 的 tools 和 platform-tools 目录添加到 PATH 变量中，以便在终端中运行一些 Android 工具 7、创建新项目使用 React Native 命令行工具来创建一个名为”AwesomeProject”的新项目： 1react-native init AwesomeProject --version 0.55.4 8、下载夜神模拟器模拟器相关配置可参考https://www.cnblogs.com/piaobodewu/p/9786513.html 启动模拟器 cmd 进入夜神模拟器安装目录的 bin 目录下D:\Program Files\Nox\bin执行nox_adb devices，然后应该就有模拟器的名字了，一般都是 127.0.0.1:62001 cmd 进去 android 的 SDK 的 platform-tools 目录下D:\android_sdk\platform-tools执行命令adb.exe connect 127.0.0.1:62001连接模拟器 进入项目根目录将项目打包安装到模拟器react-native run-android 9、启动项目(项目根目录打包安装到模拟器) 1react-native run-android 初始化项目运行可能会遇见的问题 真机红屏报错: https://www.cnblogs.com/piaobodewu/p/9889460.html 创建工程 gradle-2.4-all 包下载问题: https://blog.csdn.net/u010411264/article/details/53636956]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue路由动态权限控制]]></title>
    <url>%2F2019%2F08%2F04%2Fvue%E8%B7%AF%E7%94%B1%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前一段时间公司做了一个 oa 系统，涉及到菜单权限相关的。经过调研（又称 google），发现 vue2.2.0 之后添加的 addRoutes 功能甚是好用。整个过程踩了很多坑，因此简单整理了以下。 具体实现 创建 vue 实例的时候将 vue-router 挂载，但这个时候 vue-router 挂载一些登录或者不用权限的公用的页面 当用户登录后，获取用户角色 role，将 role 和路由表的每个页面需要的权限作比较，生成最终用户可访问的路由表 调用 router.addRoutes(store.getters.addRouters)添加用户可访问的路由 使用 vuex 管理路由表，根据 vuex 中可访问的路由渲染侧边栏组件 router.js 通过vue-router官方的 meta 标签来标示该页面能访问的权限有哪些。比如meta: { role: [&#39;admin&#39;,&#39;ceo&#39;] }表示该页面只有 admin 和 ceo 才有进入的权限。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// router.jsimport Vue from 'vue';import VueRouter from "vue-router";Vue.use(VueRouter);import Login from '@/views/login'//所有权限通用路由表//如首页和登录页和一些不用权限的公用页面export const constantRouterMap = [ &#123; path: '/login', component: Login &#125;,]//异步挂载的路由//动态需要根据权限加载的路由表export const asyncRouterMap = [ &#123; path: "/achievements", name: "achievements", component: achievements, children: [ &#123; path: "employeeAchievements", name: "employeeAchievements", component: () =&gt; import("@/views/achievements/components/employeeAchievements"), meta: &#123; roles: ["ceo"] &#125; &#125;, &#123; path: "departmentAchievements", name: "departmentAchievements", component: () =&gt; import("@/views/achievements/components/departmentAchievements"), meta: &#123; roles: ["department_head"] &#125; &#125;, &#123; path: "subordinateAchievements", name: "subordinateAchievements", component: () =&gt; import("@/views/achievements/components/subordinateAchievements"), meta: &#123; roles: ["direct_supervisor", "project_manger", "general_manager"] &#125; &#125;, &#123; path: "strategyAchievements", name: "strategyAchievements", component: () =&gt; import("@/views/achievements/components/strategyAchievements"), meta: &#123; roles: ["ceo"] &#125; &#125;, &#123; path: "personalAchievements", name: "personalAchievements", component: () =&gt; import("@/views/achievements/components/personalAchievements"), meta: &#123; roles: ["employee"] &#125; &#125;, &#123; path: "projectAchievements", name: "projectAchievements", component: () =&gt; import("@/views/achievements/components/projectAchievements"), meta: &#123; roles: ["project_manger", "general_manager"] &#125; &#125; ] &#125;, &#123; path: "*", redirect: "/achievements" &#125;];// 实例化vue的时候只挂载constantRouterMapconst createRouter = () =&gt; new VueRouter(&#123; scrollBehavior: () =&gt; (&#123; y: 0 &#125;), routes： constantRouterMap&#125;)// 通过addRoutes动态添加的路由，如何动态删除（用户权限变化或用户登出）// 参考`https://juejin.im/post/5c92ff94f265da6128275a85#heading-4` `https://github.com/vuejs/vue-router/issues/1234#issuecomment-357941465`const router = createRouter()export function resetRouter() &#123; const newRouter = createRouter() router.matcher = newRouter.matcher&#125;export default router main.js 在vue-router的全局前置守卫router.beforeEach中获取用户对应权限信息，并用 addRoutes 动态添加可访问路由表 123456789101112131415161718192021222324252627282930313233343536373839404142// main.jsimport Vue from "vue";import router from "@/router";import App from "./App.vue";import store from "@/store";import iView from "iview";Vue.use(iView);router.beforeEach(async (to, from, next) =&gt; &#123; // to and from are both route objects. must call `next`. const hasRoles = store.state.user.roles &amp;&amp; store.state.user.roles.length &gt; 0; // 判断是否有用户角色信息 if (hasRoles) &#123; // 有用户权限信息，说明所有可访问路由已生成，如访问没权限页面会自动进入404页面 next(); &#125; else &#123; // 没有用户权限信息，先拉取用户信息 try &#123; const roles = await store.dispatch("user/getInfo"); // 获取到用户权限信息 // eslint-disable-next-line const accessRoutes = await store.dispatch( // 生成可访问的路由表 "permission/generateRoutes", roles ); router.addRoutes(accessRoutes); // 动态添加可访问路由表 if (to.name === "/") &#123; next(&#123; name: "home", replace: true &#125;); &#125; else &#123; next(&#123; ...to, replace: true &#125;); // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record &#125; &#125; catch (err) &#123; console.log(err); &#125; &#125;&#125;);router.afterEach((to, from, next) =&gt; &#123; iView.LoadingBar.finish(); window.scrollTo(0, 0);&#125;); store/permission.js 通过用户的权限和之前在 router.js 里面 asyncRouterMap 的每一个页面所需要的权限做匹配，最后返回一个该用户能够访问路由有哪些 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// store/permission.jsimport &#123; constantRouterMap, asyncRouterMap &#125; from "@/router"; // 引入静态路由和动态路由function hasPermission(roles, route) &#123; // 遍历判断是否有进入该页面的权限 if (route.meta &amp;&amp; route.meta.roles) &#123; return roles.some(role =&gt; route.meta.roles.includes(role)); &#125; return true;&#125;function deepCopy(source) &#123; // 深拷贝 if (!source) &#123; return source; &#125; let sourceCopy = source instanceof Array ? [] : &#123;&#125;; for (let item in source) &#123; sourceCopy[item] = typeof source[item] === "object" ? deepCopy(source[item]) : source[item]; &#125; return sourceCopy;&#125;export function filterAsyncRoutes(routes, roles) &#123; // 过滤生成可访问路由表 const res = []; routes.forEach(route =&gt; &#123; const tmp = &#123; ...route &#125;; if (hasPermission(roles, tmp)) &#123; if (tmp.children) &#123; tmp.children = filterAsyncRoutes(tmp.children, roles); &#125; res.push(tmp); &#125; &#125;); return res;&#125;export default &#123; namespaced: true, state: &#123; routes: deepCopy(constantRouterMap), addRoutes: [] &#125;, getters: &#123;&#125;, mutations: &#123; SET_ROUTES: (state, routes) =&gt; &#123; state.addRoutes = routes; state.routes = deepCopy(constantRouterMap.concat(routes)); &#125; &#125;, actions: &#123; generateRoutes(&#123; commit &#125;, roles) &#123; return new Promise(resolve =&gt; &#123; let accessedRoutes = filterAsyncRoutes(asyncRouterMap, roles); commit("SET_ROUTES", deepCopy(accessedRoutes)); resolve(accessedRoutes); &#125;); &#125; &#125;&#125;; store/user.js 获取用户对应的 role 之前，需要先拿到 token。详细流程如下： 登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个 token，拿到 token 之后（我会将这个 token 存贮到 cookie 中，保证刷新页面后能记住用户登录状态），前端会根据 token 再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。 权限验证：通过 token 获取用户对应的 role，动态根据用户的 role 算出其对应有权限的路由，通过 router.addRoutes 动态挂载这些路由。 123456789101112131415161718192021222324252627export default &#123; namespaced: true, state: &#123; token: "", isHr: true, roles: [] &#125;, getters: &#123;&#125;, mutations: &#123; SET_TOKEN: (state, token) =&gt; &#123; state.token = token; &#125;, SET_ROLES: (state, roles) =&gt; &#123; state.roles = roles; &#125; &#125;, actions: &#123; getInfo(&#123; commit, state &#125;) &#123; // 获取用户信息接口，拿到服务端返回的token、用户名、用户权限等信息 return new Promise((resolve, reject) =&gt; &#123; const rolesFromSeivice = ["ceo"]; // 从接口拿到的用户权限信息（用户角色） commit("SET_ROLES", rolesFromSeivice); resolve(rolesFromSeivice); &#125;); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流年博客的Hello World]]></title>
    <url>%2F2019%2F01%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[你好，我是流年，进阶全栈的路上···]]></content>
  </entry>
</search>
