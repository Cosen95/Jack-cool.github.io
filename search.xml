<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解浏览器的缓存机制]]></title>
    <url>%2F2019%2F09%2F02%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[都 9102 年了，你还不懂浏览器的缓存机制？没错，我之前对这块是相当的薄弱，也逐渐在开发中感受到了缓存的作用。缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。 既然缓存这么强，你还有什么理由不去深入了解一下呢？ Let’s got it! 缓存位置从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。 Service Worker Memory Cache Disk Cache Push Cache Service WorkerService Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。 Memory CacheMemory Cache 也就是内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放（一旦我们关闭 Tab 页面，内存中的缓存也就被释放了）。 内存缓存中有一块重要的缓存资源是 preloader 相关指令（例如&lt;link rel=&quot;prefetch&quot;&gt;）众所周知 preloader 的相关指令已经是页面优化的常见手段之一，它可以一边解析 js/css 文件，一边网络请求下一个资源。 Disk CacheDisk Cache 也就是存储在硬盘中的缓存，读取速度虽然慢点，但是什么都能存储到磁盘中，与 Memory Cache 相比，优势是容量和存储时效性。 在所有浏览器缓存中，Disk Cache 覆盖面基本上是最大的。它会根据 HTTP Header 中的字段判断哪些资源缓存（不用慌，关于 HTTP 的协议头中的缓存字段，会在下面详细介绍的），哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？ 关于这点，网上说法不一，不过以下两点比较靠得住： 对于大文件来说，大概率是不存储在内存中的 当前系统内存使用率高的话，文件优先存进硬盘 Push CachePush Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂。 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。 为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。 缓存过程分析浏览器与服务器通信的方式为应答模式，即： 浏览器发起 HTTP 请求 &gt;&gt; 服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图： 由上图我们可以知道： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。 以上两点是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取。下面说一下浏览器缓存的使用规则。根据是否需要向服务器重新发起 HTTP 请求将缓存过程分为两个部分，分别是强缓存和协商缓存。 强缓存强缓存： 不会向服务器发起请求，直接从缓存中读取资源，在 chrome 控制台的 Network 选项中可以看到该请求返回 200 的状态码，并且size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现： Expires 和 Cache-Control 1、 Expires 缓存过期时间，用来指定资源到期的时间，是服务端的具体时间点。也就是说，Expires=max-age + 请求时间，需要和 Last-modified 结合使用。Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 2、 Cache-Control 在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存。 Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令： public: 所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，中间的 proxy 可以缓存资源，下次再请求同一资源，proxy1 直接把自己缓存的东西给 Browser 而不再向 proxy2 要。 private: 所有内容只有客户端可以缓存，Cache-Control 的默认取值。具体来说，表示中间节点不允许缓存，对于 Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，proxy 会老老实实把 Server 返回的数据发送给 proxy1，自己不缓存任何数据。当下次 Browser 再次请求时 proxy 会做好请求转发而不是自作主张给自己缓存的数据 no-cache: 客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control 的缓存控制方式来做前置验证，而是使用 Etag 或者 Last-Modified 字段来控制缓存。需要注意的是，no-cache 这个名字有点误导。设置了 no-cache 之后，并不是说浏览器就不再缓存数据，而是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。 no-store: 所有内容都不会被缓存，即不使用强缓存，也不使用协商缓存 max-age: max-age=xxx(xxx is numeric)表示缓存内容将在 xxx 秒后失效 s-maxage: 同 max-age 作用一样，只在代理服务器中生效。max-age 用于普通缓存，而 s-maxage 用于代理缓存。s-maxage 的优先级高于 max-age。如果存在 s-maxage，则会覆盖掉 max-age 和 Expires header max-stale: 能容忍的最大过期时间。max-stale 指令标识了客户端愿意接受一个已经过期了的响应。如果指定了 max-stale 的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何 age 的响应（age 表示响应由源站生成或确认的时间与当前时间的差值）。 min-fresh: 能够容忍的最小新鲜度。min-fresh 标识了客户端不愿意接受新鲜度不多于当前的 age 加上 min-fresh 设定的时间之和的响应 3、 Expires 和 Cache-Control 两者对比 其实这两者差别不大，区别就在于 Expires 是 http1.0 的产物，Cache-Control 是 http1.1 的产物，两者同时存在的话，Cache-Control 优先级高于 Expires；在某些不支持 HTTP1.1 的环境下，Expires 就会发挥用处。所以 Expires 其实是过时的产物，现阶段它的存在只是一种兼容性的写法。 强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回 304 和 Not Modified 协商缓存成功，返回 200 和请求结果 协商缓存可以通过设置两种 HTTP Header 实现： Last-Modified 和 ETag 1、 Last-Modified 和 If-Modified-Since 浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 header： 1Last-Modified: Mon, 02 Sep 2019 18:10:00 GMT 浏览器下一次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是添加 If-Modified-Since 这个 header，值就是 Last-Modified 中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回 304 和空的响应体，直接从缓存读取，如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和 200。 但是 Last-Modified 存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源; 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源。 既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和 If-None-Match。 2、 ETag 和 If-None-Match Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识 (由服务器生成)，只要资源有变化，Etag 就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 Etag 值放到 request header 里的 If-None-Match 里，服务器只需要比较客户端传来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现 ETag 匹配不上，那么直接以常规 GET 200 回包形式将新的资源（当然也包括了新的 ETag）发给客户端；如果 ETag 是一致的，则直接返回 304 知会客户端直接使用本地缓存即可。 3、 两者之间对比 首先在精确度上，Etag 要优于 Last-Modifie，Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的 Last-Modified 也有可能不一致; 第二在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值; 第三在优先级上，服务器校验优先考虑 Etag。 缓存机制强制缓存优先于协商缓存进行，若强制缓存 (Expires 和 Cache-Control) 生效则直接使用缓存，若不生效则进行协商缓存 (Last-Modified / If-Modified-Since 和 Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回 304，继续使用缓存。具体流程图如下： 看到这里，不知道你是否存在这样一个疑问:如果什么缓存策略都没设置，那么浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。 实际场景应用缓存策略 频繁变动的资源 对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。 不常变化的资源 通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名 (或者路径) 中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。 用户行为对浏览器缓存的影响所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种： 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求； 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用 (如果匹配的话)。其次才是 disk cache； 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache), 服务器直接返回 200 和最新内容。]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端应该晓得的web登录]]></title>
    <url>%2F2019%2F08%2F27%2F%E5%89%8D%E7%AB%AF%E5%BA%94%E8%AF%A5%E6%99%93%E5%BE%97%E7%9A%84web%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[为什么会有登录这回事首先这是因为 HTTP 是无状态的协议。所谓无状态就是在两次请求之间服务器不会保存任何的数据。所以，登录就是用某种方法让服务器在多次请求之间能够识别出你，而不是每次发请求都得带上用户名密码这样的识别身份的信息。从登录成功到登出的这个过程，服务器一直维护了一个可以识别出用户信息的数据结构，广义上来说，这个过程就叫做 session，也就是保持了一个会话。 常见的两种登录服务器 session + 客户端 sessionId 客户端带着用户名和密码去访问/login 接口，服务器端收到后校验用户名和密码，校验正确就会在服务器端存储一个 sessionId 和 session 的映射关系。 服务器端返回 response，并且将 sessionId 以 set-cookie 的方式种在客户端，这样，sessionId 就存在了客户端。这里要注意的是，将 sessionId 存在 cookie 并不是一种强制的方法，而是大家一般都这么做，而且发请求的时候符合 domain 和 path 的时候，会自动带上 cookie，省去了手动塞的过程。 客户端发起非登录请求时，假如服务器给了 set-cookie，浏览器会自动在请求头中添加 cookie 服务器接收请求，分解 cookie，验证信息，核对成功后返回 response 给客户端 token 前面说到 sessionId 方式的本质是把用户信息维护在 serve 端，token 方式就是把用户的状态信息加密成一串 token 传给前端，然后每次发请求时把 token 带上，传回给服务端。服务端收到请求之后，解析 token 并且验证相关信息 token 也称作令牌，由 uid+time+sign+固定参数。 token 的认证方式类似于临时的证书签名，并且是一种服务端无状态的认证方式，非常适合于 REST API 的场景。所谓无状态就是服务端并不会保存身份认证相关的数据。组成: uid: 用户唯一身份标识 time: 当前时间的时间戳 sign: 签名，使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接 固定参数（可选）: 将一些常用的固定参数加入到 token 中是为了避免重复查库 认证流程: 用户登录，成功后服务器返回 Token 给客户端 客户端收到数据后保存在客户端 客户端再次访问服务器，将 token 放入 headers 中 服务器端采用 filter 过滤器校验。检验成功后则返回请求数据，校验失败则返回错误码 业界通用的加密方式是jwt（json web token） JWTJWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样: 12345&#123; &quot;姓名&quot;: &quot;张三&quot;, &quot;角色&quot;: &quot;管理员&quot;, &quot;到期时间&quot;: &quot;2019年8月27日0点0分&quot;&#125; 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认证用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。 服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。 JWT 的格式大致如下: 它是一个很长的字符串，中间用点（.）分隔成三个部分。 JWT 的三个部分依次如下: 1234Header(头部)Payload(负载)Signature(签名) 下面简单介绍一下这三部分: Header Header 部分是一个 JSON 对象，描述 JWT 的元数据。 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; 上面代码中，alg属性表示签名的算法，默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。 最后，将上面的 JSON 对象使用Base64URL算法转成字符串。 Payload Payload 部分也是一个 JSON 对象，里面放的是用户的信息，用来存放实际需要传递的数据。JWT 规定了 7 个官方字段，供选用。 1234567iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号 注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。 这个 JSON 对象也要使用Base64URL算法转成字符串。 Signature Signature 部分是对前两部分的签名，防止数据篡改。 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。即最终的 jwt 为： 1jwt = base64url(header) + &quot;.&quot; + base64url(payload) + &quot;.&quot; + signature jwt 可以放在 response 中返回，也可以放在 cookie 中返回，这都是具体的返回方式，并不重要。客户端发起请求时，官方推荐放在 HTTP header 中： 1Authorization: Bearer &lt;token&gt;]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>session</tag>
        <tag>cookie</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hooks与React生命周期的关系]]></title>
    <url>%2F2019%2F08%2F24%2FHooks%E4%B8%8EReact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[React 生命周期很多人都了解，但通常我们所了解的都是 单个组件 的生命周期，但针对 Hooks 组件、多个关联组件（父子组件和兄弟组件） 的生命周期又是怎么样的喃？你有思考和了解过吗，接下来我们将完整的了解 React 生命周期。 Hooks 组件函数组件的本质是函数，没有 state 的概念的，因此不存在生命周期一说，仅仅是一个 render 函数而已。 但是引入Hooks之后就变得不同了，它能让组件在不使用 class 的情况下拥有 state，所以就有了生命周期的概念 即：Hooks 组件（使用了 Hooks 的函数组件）有生命周期，而函数组件（未使用 Hooks 的函数组件）是没有生命周期的 下面，是具体的 class 与 Hooks 的生命周期对应关系 constructor函数组件不需要构造函数，我们可以通过调用useState来初始化 state getDerivedStateFromProps一般情况下，我们不需要使用它，我们可以在渲染过程中更新state，以达到实现 getDerivedStateFromProps 的目的 shouldComponentUpdate可以用React.memo包裹一个组件对它的 props 进行浅比较const Comp = React.memeo((props) =&gt; { // 具体的组件 })注意： React.memo 等价于 PureComponent，它只浅比较 props，这里也可以使用 useMemo 优化每一个节点 render这是函数组件体本身 componentDidMount可以使用useEffect处理副作用useEffect(() =&gt; { // 在componentDidMount执行的内容 }, [count]) // 仅在count更改时更新 componentWillUnmount相当于 useEffect 里面返回的 cleanup 函数useEffect(() =&gt; { // 需要在componentDidMount执行的内容 return function cleanup() { // 需要在componentWillUnmount执行的内容 } }) componentDidCatch &amp;&amp; getDerivedStateFromError目前还没有这些方法的 Hook 等价写法 大致汇总成表格如下： class 组件 Hooks 组件 constructor useState getDerivedStateFromProps useState 里面 update 函数 shouldComponentUpdate useMemo render 函数本身 componentDidMount useEffect componentDidUpdate useEffect componentWillUnmount useEffect 里面返回的函数 componentDidCatch 无 getDerivedStateFromError 无 单个组件的生命周期组件的生命周期可以分为三个阶段: 挂载阶段 组件更新阶段 挂载阶段 v16.3 之前 挂载阶段 - constructor - componentWillMount - render: react 最重要的步骤，创建虚拟 dom，进行 diff 算法，更新 dom 树都在此进行 - componentDidMount 组件更新阶段 - componentWillReceiveProps - shouldComponentUpdate - componentWillUpdate - render - componentDidUpdate 卸载阶段 - componentWillUnmount 这种生命周期会存在一个问题，那就是当更新复杂组件的最上层组件时，调用栈会很长，如果再进行复杂的操作，就可能长时间阻塞主线程，带来不好的用户体验。 所以 v16.3 引入了新的 API 来解决这个问题 v16.3 之后 static getDerivedStateFromProps: 该函数在挂载阶段和组件更新阶段都会执行，即每次获取新的 props 或 state 之后都会被执行，在挂载阶段用来代替 componentWillMount；在组件更新阶段配合 componentDidUpdate，可以覆盖 componentWillReceiveProps 的所有用法。 同时它是一个静态函数，所以函数体内不能访问 this，会根据 nextProps 和 prevState 计算出预期的状态改变，返回结果会被送给 setState，返回 null 则说明不需要更新 state，并且这个返回是必须的。 getSnapshotBeforeUpdate: 该函数会在 render 之后，DOM 更新前被调用，用于读取最新的 DOM 数据。 返回一个值，作为 componentDidUpdate 的第三个参数。配合 componentDidUpdate，可以覆盖 componentWillUpdate 的所有用法。 即更新后的生命周期为： 挂载阶段 - constructor - static getDerivedStateFromProps - render - componentDidMount 更新阶段 - static getDerivedStateFromProps - shouldComponentUpdate - render - getSnapshotBeforeUpdate - componentDidUpdate 卸载阶段 - componentWillUnmount]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>Hooks</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tsconfig.json 配置详解]]></title>
    <url>%2F2019%2F08%2F05%2Ftsconfig-json-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[因为工作中用到了 typescript，抽时间，先大致介绍一下 tsconfig 配置文件，完整的 ts 学习还是建议从官方教程出发，玩儿的愉快 tsconfig.json 配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&#123; "compilerOptions": &#123; /* Basic Options */ "target": "es5" /* target用于指定编译之后的版本目标: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019' or 'ESNEXT'. */, "module": "commonjs" /* 用来指定要使用的模块标准: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */, "lib": ["es6", "dom"] /* lib用于指定要包含在编译中的库文件 */, "allowJs": true, /* allowJs设置的值为true或false，用来指定是否允许编译js文件，默认是false，即不编译js文件 */ "checkJs": true, /* checkJs的值为true或false，用来指定是否检查和报告js文件中的错误，默认是false */ "jsx": "preserve", /* 指定jsx代码用于的开发环境: 'preserve', 'react-native', or 'react'. */ "declaration": true, /* declaration的值为true或false，用来指定是否在编译的时候生成相应的".d.ts"声明文件。如果设为true，编译每个ts文件之后会生成一个js文件和一个声明文件。但是declaration和allowJs不能同时设为true */ "declarationMap": true, /* 值为true或false，指定是否为声明文件.d.ts生成map文件 */ "sourceMap": true, /* sourceMap的值为true或false，用来指定编译时是否生成.map文件 */ "outFile": "./", /* outFile用于指定将输出文件合并为一个文件，它的值为一个文件路径名。比如设置为"./dist/main.js"，则输出的文件为一个main.js文件。但是要注意，只有设置module的值为amd和system模块时才支持这个配置 */ "outDir": "./", /* outDir用来指定输出文件夹，值为一个文件夹路径字符串，输出的文件都将放置在这个文件夹 */ "rootDir": "./", /* 用来指定编译文件的根目录，编译器会在根目录查找入口文件，如果编译器发现以rootDir的值作为根目录查找入口文件并不会把所有文件加载进去的话会报错，但是不会停止编译 */ "composite": true, /* 是否编译构建引用项目 */ "incremental": true, /* Enable incremental compilation */ "tsBuildInfoFile": "./", /* Specify file to store incremental compilation information */ "removeComments": true, /* removeComments的值为true或false，用于指定是否将编译后的文件中的注释删掉，设为true的话即删掉注释，默认为false */ "noEmit": true, /* 不生成编译文件，这个一般比较少用 */ "importHelpers": true, /* importHelpers的值为true或false，指定是否引入tslib里的辅助工具函数，默认为false */ "downlevelIteration": true, /* 当target为'ES5' or 'ES3'时，为'for-of', spread, and destructuring'中的迭代器提供完全支持 */ "isolatedModules": true, /* isolatedModules的值为true或false，指定是否将每个文件作为单独的模块，默认为true，它不可以和declaration同时设定 */ /* Strict Type-Checking Options */ "strict": true /* strict的值为true或false，用于指定是否启动所有类型检查，如果设为true则会同时开启下面这几个严格类型检查，默认为false */, "noImplicitAny": true, /* noImplicitAny的值为true或false，如果我们没有为一些值设置明确的类型，编译器会默认认为这个值为any，如果noImplicitAny的值为true的话。则没有明确的类型会报错。默认值为false */ "strictNullChecks": true, /* strictNullChecks为true时，null和undefined值不能赋给非这两种类型的值，别的类型也不能赋给他们，除了any类型。还有个例外就是undefined可以赋值给void类型 */ "strictFunctionTypes": true, /* strictFunctionTypes的值为true或false，用于指定是否使用函数参数双向协变检查 */ "strictBindCallApply": true, /* 设为true后会对bind、call和apply绑定的方法的参数的检测是严格检测的 */ "strictPropertyInitialization": true, /* 设为true后会检查类的非undefined属性是否已经在构造函数里初始化，如果要开启这项，需要同时开启strictNullChecks，默认为false */ "noImplicitThis": true, /* 当this表达式的值为any类型的时候，生成一个错误 */ "alwaysStrict": true, /* alwaysStrict的值为true或false，指定始终以严格模式检查每个模块，并且在编译之后的js文件中加入"use strict"字符串，用来告诉浏览器该js为严格模式 */ /* Additional Checks */ "noUnusedLocals": true, /* 用于检查是否有定义了但是没有使用的变量，对于这一点的检测，使用eslint可以在你书写代码的时候做提示，你可以配合使用。它的默认值为false */ "noUnusedParameters": true, /* 用于检查是否有在函数体中没有使用的参数，这个也可以配合eslint来做检查，默认为false */ "noImplicitReturns": true, /* 用于检查函数是否有返回值，设为true后，如果函数没有返回值则会提示，默认为false */ "noFallthroughCasesInSwitch": true, /* 用于检查switch中是否有case没有使用break跳出switch，默认为false */ /* Module Resolution Options */ "moduleResolution": "node", /* 用于选择模块解析策略，有'node'和'classic'两种类型' */ "baseUrl": "./", /* baseUrl用于设置解析非相对模块名称的基本目录，相对模块不会受baseUrl的影响 */ "paths": &#123;&#125;, /* 用于设置模块名称到基于baseUrl的路径映射 */ "rootDirs": [], /* rootDirs可以指定一个路径列表，在构建时编译器会将这个路径列表中的路径的内容都放到一个文件夹中 */ "typeRoots": [], /* typeRoots用来指定声明文件或文件夹的路径列表，如果指定了此项，则只有在这里列出的声明文件才会被加载 */ "types": [], /* types用来指定需要包含的模块，只有在这里列出的模块的声明文件才会被加载进来 */ "allowSyntheticDefaultImports": true, /* 用来指定允许从没有默认导出的模块中默认导入 */ "esModuleInterop": true /* 通过为导入内容创建命名空间，实现CommonJS和ES模块之间的互操作性 */, "preserveSymlinks": true, /* 不把符号链接解析为其真实路径，具体可以了解下webpack和nodejs的symlink相关知识 */ /* Source Map Options */ "sourceRoot": "", /* sourceRoot用于指定调试器应该找到TypeScript文件而不是源文件位置，这个值会被写进.map文件里 */ "mapRoot": "", /* mapRoot用于指定调试器找到映射文件而非生成文件的位置，指定map文件的根路径，该选项会影响.map文件中的sources属性 */ "inlineSourceMap": true, /* 指定是否将map文件的内容和js文件编译在同一个js文件中，如果设为true，则map的内容会以//# sourceMappingURL=然后拼接base64字符串的形式插入在js文件底部 */ "inlineSources": true, /* 用于指定是否进一步将.ts文件的内容也包含到输入文件中 */ /* Experimental Options */ "experimentalDecorators": true /* 用于指定是否启用实验性的装饰器特性 */ "emitDecoratorMetadata": true, /* 用于指定是否为装饰器提供元数据支持，关于元数据，也是ES6的新标准，可以通过Reflect提供的静态方法获取元数据，如果需要使用Reflect的一些方法，需要引入ES2015.Reflect这个库 */ &#125; "files": [], // files可以配置一个数组列表，里面包含指定文件的相对或绝对路径，编译器在编译的时候只会编译包含在files中列出的文件，如果不指定，则取决于有没有设置include选项，如果没有include选项，则默认会编译根目录以及所有子目录中的文件。这里列出的路径必须是指定文件，而不是某个文件夹，而且不能使用* ? **/ 等通配符 "include": [], // include也可以指定要编译的路径列表，但是和files的区别在于，这里的路径可以是文件夹，也可以是文件，可以使用相对和绝对路径，而且可以使用通配符，比如"./src"即表示要编译src文件夹下的所有文件以及子文件夹的文件 "exclude": [], // exclude表示要排除的、不编译的文件，它也可以指定一个列表，规则和include一样，可以是文件或文件夹，可以是相对路径或绝对路径，可以使用通配符 "extends": "", // extends可以通过指定一个其他的tsconfig.json文件路径，来继承这个配置文件里的配置，继承来的文件的配置会覆盖当前文件定义的配置。TS在3.2版本开始，支持继承一个来自Node.js包的tsconfig.json配置文件 "compileOnSave": true, // compileOnSave的值是true或false，如果设为true，在我们编辑了项目中的文件保存的时候，编辑器会根据tsconfig.json中的配置重新生成文件，不过这个要编辑器支持 "references": [], // 一个对象数组，指定要引用的项目&#125;]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4打造极致开发环境]]></title>
    <url>%2F2019%2F08%2F05%2Fwebpack4%E6%89%93%E9%80%A0%E6%9E%81%E8%87%B4%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 webpack 已经是大部分前端项目打包工具的首选，grunt、glup、browserify 等逐渐沦为辅助甚至完全被替代。在 grunt、glup、browserify 等已经相当火了之后，webpack 长江后浪推前浪，把前辈们拍死在沙滩上，实力惊人。 本文主要从 webpack4.x 入手，会对平时常用的 Webpack 配置一一讲解，各个功能点都有对应的详细例子，所以本文也比较长，但如果你能动手跟着本文中的例子完整写一次，相信你会觉得 Webpack 也不过如此。 安装 webpack 的几种方式 global(全局):通过 webpack index.js 运行 local(项目维度安装):通过 npx webpack index.js 运行 知识点总结 避免全局安装 webpack（针对多个项目采用不同的 webpack 版本进行打包的场景），可采用npx，具体可参考http://www.ruanyifeng.com/blog/2019/02/npx.html npx webpack --config 配置文件名可指定 webpack 配置文件（默认为 webpack.config.js） mode 选项(可能的值为 none、development 或 production(默认值))配置用于提供模式配置选项告诉 webpack 相应的使用其内置的优化。具体可参考https://webpack.js.org/configuration/mode/#root npm scripts:通过配置 package.json 里面的 scripts 字段，直接运行 webpack 即可。等价于yarn run bundle -&gt; webpack file-loader 可打包处理eot|svg|ttf|woff等字体文件 entry(入口)单一入口1234567// webpack.config.jsconst config = &#123; entry: &#123; main: "./src/index.js" &#125;&#125;; 多入口12345678// webpack.config.jsconst config = &#123; entry: &#123; main: "./src/index.js", sub: "./src/sub.js" &#125;&#125;; output(输出)默认配置123456789101112// webpack.config.jsconst path = require('path');...const config = &#123; output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;;module.exports = config; 多个入口起点 如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。 1234567891011121314// webpack.config.jsconst path = require('path');&#123; entry: &#123; main: './src/index.js', sub: './src/sub.js' &#125;, output: &#123; filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125;// 写入到硬盘：./dist/main.js, ./dist/sub.js 高级进阶 使用 cdn 123456789101112131415// webpack.config.jsconst path = require('path');&#123; entry: &#123; main: './src/index.js', sub: './src/sub.js' &#125;, output: &#123; publicPath: 'http://cdn.example.com' filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125;// 写入到http://cdn.example.com/main.js, http://cdn.example.com/sub.js loaders webpack 可以使用 loader 来预处理文件。这允许你打包除 JavaScript 之外的任何静态资源。 file-loader file-loader 可以解析项目中的 url 引入（不仅限于 css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。 默认情况下，生成的文件的文件名就是文件内容的 MD5 哈希值并会保留所引用资源的原始扩展名。 123456789101112rules: [ &#123; test: /\.(jpg|png|gif)$/, use: &#123; loader: "file-loader", options: &#123; name: "[name]_[hash].[ext]", outputPath: "images/" &#125; &#125; &#125;]; url-loader url-loader 功能类似于 file-loader，但是在文件大小（单位 byte）低于指定的限制时，可以返回一个 DataURL。 url-loader 把资源文件转换为 URL，file-loader 也是一样的功能。不同之处在于 url-loader 更加灵活，它可以把小文件转换为 base64 格式的 URL，从而减少网络请求次数。url-loader 依赖 file-loader。 12345678910111213rules: [ &#123; test: /\.(jpg|png|gif)$/, use: &#123; loader: "url-loader", options: &#123; name: "[name]_[hash].[ext]", outputPath: "images/", limit: 204800 &#125; &#125; &#125;]; css-loader 只负责加载 css 模块,不会将加载的 css 样式应用到 html importLoaders 用于指定在 css-loader 前应用的 loader 的数量 查询参数 modules 会启用 CSS 模块规范 12345678module: &#123; rules: [ &#123; test: /\.css$/, use: ["style-loader", "css-loader"] &#125; ];&#125; style-loader 负责将 css-loader 加载到的 css 样式动态的添加到 html-head-style 标签中 一般建议将 style-loader 与 css-loader 结合使用 sass-loader安装yarn add sass-loader node-sass webpack --dev node-sass 和 webpack 是 sass-loader 的 peerDependency，因此能够精确控制它们的版本。 loader 执行顺序：从下至上，从右至左 通过将 style-loader 和 css-loader 与 sass-loader 链式调用，可以立刻将样式作用在 DOM 元素。 12345678910111213141516// webpack.config.jsmodule.exports = &#123;...module: &#123; rules: [&#123; test: /\.scss$/, use: [&#123; loader: "style-loader" // 将 JS 字符串生成为 style 节点 &#125;, &#123; loader: "css-loader" // 将 CSS 转化成 CommonJS 模块 &#125;, &#123; loader: "sass-loader" // 将 Sass 编译成 CSS &#125;] &#125;]&#125;&#125;; postcss-loader webpack4 中使用 postcss-loader 代替 autoprefixer，给 css3 样式加浏览器前缀。具体可参考https://blog.csdn.net/u014628388/article/details/82593185 1234567891011121314151617// webpack.config.js &#123; test: /\.scss$/, use: [ 'style-loader', 'css-loader', 'sass-loader', 'postcss-loader' ],&#125;//postcss.config.jsmodule.exports = &#123; plugins: [ require('autoprefixer')(&#123; browsers: ['last 2 versions'] &#125;), ],&#125;; plugins plugin 可以在 webpack 运行到某个时刻的时候，帮你做一些事情 HtmlWebpackPlugin HtmlWebpackPlugin 会在打包结束后，自动生成一个 html 文件，并把打包生成的 js 自动引入到这个 html 文件中 12345678910const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123;...plugins: [ new HtmlWebpackPlugin(&#123; template: 'src/index.html' &#125;), ],&#125;; clean-webpack-plugin clean-webpack-plugin 插件用来清除残留打包文件，特别是文件末尾添加了 hash 之后，会导致改变文件内容后重新打包时，文件名不同而内容越来越多。 新版本中的 clean-webpack-plugin 仅接受一个对象，默认不需要传任何参数。具体可参考https://blog.csdn.net/qq_23521659/article/details/88353708 1234567891011const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');module.exports = &#123;...plugins: [ new CleanWebpackPlugin() ], output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125; SplitChunksPlugin 具体概念可参考https://juejin.im/post/5af15e895188256715479a9a 1234567891011121314151617181920splitChunks: &#123; chunks: "async", minSize: 30000, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\/]node_modules[\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125;&#125; MiniCssExtractPlugin 将 CSS 提取为独立的文件的插件，对每个包含 css 的 js 文件都会创建一个 CSS 文件，支持按需加载 css 和 sourceMap 123456789101112131415161718192021222324252627282930313233343536373839404142const MiniCssExtractPlugin = require("mini-css-extract-plugin");module.exports = &#123; plugins: [ new MiniCssExtractPlugin(&#123; // Options similar to the same options in webpackOptions.output // both options are optional filename: "[name].css", chunkFilename: "[id].css" &#125;) ], module: &#123; rules: [ &#123; test: /\.scss$/, use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, &#123; loader: "css-loader", options: &#123; importLoaders: 2 // 用于指定在 css-loader 前应用的 loader 的数量 // modules: true // 查询参数 modules 会启用 CSS 模块规范 &#125; &#125;, "sass-loader", "postcss-loader" ] &#125;, &#123; test: /\.css$/, use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, "css-loader", "postcss-loader" ] &#125; ] &#125;&#125;; OptimizeCSSAssetsPlugin webpack5 可能会内置 CSS 压缩器，webpack4 需要自己使用压缩器，可以使用 optimize-css-assets-webpack-plugin 插件。 设置 optimization.minimizer 覆盖 webpack 默认提供的，确保也指定一个 JS 压缩器 123456789101112131415161718192021222324252627282930const UglifyJsPlugin = require("uglifyjs-webpack-plugin");const MiniCssExtractPlugin = require("mini-css-extract-plugin");const OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin");module.exports = &#123; optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, parallel: true, sourcMap: true &#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;) ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: "[name].css", chunkFilename: "[id].css" &#125;) ], module: &#123; rules: [ &#123; test: /\.css$/, use: [MiniCssExtractPlugin.loader, "css-loader"] &#125; ] &#125;&#125;; devtoolsource map source map 就是对打包生成的代码与源代码的一种映射，主要是为了方便定位问题和排查问题。devtool 关键有 eval、cheap、module、inline 和 source-map 这几块，具体可参考文档：https://www.webpackjs.com/configuration/devtool/ development 环境参考配置: &#39;cheap-module-eval-source-map&#39; production 环境参考配置: &#39;cheap-module-source-map&#39; webpack-dev-server webpack-dev-server 提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)。具体可参考https://www.webpackjs.com/guides/development/#%E4%BD%BF%E7%94%A8-webpack-dev-server 接口代理(请求转发) 如果你有单独的后端开发服务器 API，并且希望在同域名下发送 API 请求 ，那么代理某些 URL 会很有用。dev-server 使用了非常强大的 http-proxy-middleware 包。常用于接口请求转发。具体参考https://www.webpackjs.com/configuration/dev-server/#devserver-proxy 12345678910111213141516171819devServer: &#123; contentBase: "./dist", open: true, hot: true, hotOnly: true, proxy: &#123; "/api": &#123; target: "https://other-server.example.com", pathRewrite: &#123;"^/api" : ""&#125;, secure: false, bypass: function(req, res, proxyOptions) &#123; if (req.headers.accept.indexOf("html") !== -1) &#123; console.log("Skipping proxy for browser request."); return "/index.html"; &#125; &#125; &#125; &#125; &#125;, 解决单页面路由问题 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html通过传入以下启用： 1historyApiFallback: true; 通过传入一个对象，比如使用 rewrites 这个选项，此行为可进一步地控制： 1234567historyApiFallback: &#123; rewrites: [ &#123; from: /^\/$/, to: "/views/landing.html" &#125;, &#123; from: /^\/subpage/, to: "/views/subpage.html" &#125;, &#123; from: /./, to: "/views/404.html" &#125; ];&#125; webpack-dev-middleware webpack-dev-middleware 是一个容器(wrapper)，它可以把 webpack 处理后的文件传递给一个服务器(server)。 webpack-dev-server 在内部使用了它，同时，它也可以作为一个单独的包来使用，以便进行更多自定义设置来实现更多的需求 1234567891011121314151617181920// server.js// 使用webpack-dev-middleware// https://www.webpackjs.com/guides/development/#%E4%BD%BF%E7%94%A8-webpack-dev-middlewareconst express = require("express");const webpack = require("webpack");const webpackDevMiddleware = require("webpack-dev-middleware");const config = require("./webpack.config.js");const complier = webpack(config);const app = express();app.use( webpackDevMiddleware(complier, &#123; publicPath: config.output.publicPath &#125;));app.listen(3000, () =&gt; &#123; console.log("server is running");&#125;); Hot Module Replacement 模块热替换(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新。 1234567891011121314// webpack.config.js...const webpack = require('webpack');...devServer: &#123; contentBase: './dist', open: true, hot: true, hotOnly: true&#125;,plugins: [ ... new webpack.HotModuleReplacementPlugin()], 如果已经通过 HotModuleReplacementPlugin 启用了模块热替换(Hot Module Replacement)，则它的接口将被暴露在 module.hot 属性下面。通常，用户先要检查这个接口是否可访问，然后再开始使用它。 123456// index.jsif (module.hot) &#123; module.hot.accept("./library.js", function() &#123; // 使用更新过的 library 模块执行某些操作... &#125;);&#125; bundle 分析 借助一些官方推荐的可视化分析工具，可对打包后的模块进行分析以及优化 webpack-chart: webpack 数据交互饼图 webpack-visualizer: 可视化并分析你的 bundle，检查哪些模块占用空间，哪些可能是重复使用的 webpack-bundle-analyzer: 一款分析 bundle 内容的插件及 CLI 工具，以便捷的、交互式、可缩放的树状图形式展现给用户 Preloading、Prefetching prefetch：会等待核心代码加载完成后，页面带宽空闲后再去加载 prefectch 对应的文件;preload：和主文件一起去加载 可以使用谷歌浏览器 Coverage 工具查看代码覆盖率(ctrl+shift+p &gt; show coverage) 使用异步引入 js 的方式可以提高 js 的使用率，所以 webpack 建议我们多使用异步引入的方式，这也是 splitChunks.chunks 的默认值是”async”的原因 使用魔法注释 /_ webpackPrefetch: true _/ ，这样在主要 js 加载完，带宽有空闲时，会自动下载需要引入的 js 使用魔法注释 /_ webpackPreload: true _/，区别是 webpackPrefetch 会等到主业务文件加载完，带宽有空闲时再去下载 js，而 preload 是和主业务文件一起加载的 babelbabel 编译 es6、jsx 等 @babel/core babel 核心模块 @babel-preset-env 编译 es6 等 @babel/preset-react 转换 jsx @babel/plugin-transform-runtime 避免 polyfill 污染全局变量，减少打包体积 @babel/polyfill es6 内置方法和函数转化垫片 @babel/runtime 1234567891011module: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/, use: &#123; loader: "babel-loader" &#125; &#125; ];&#125; 新建.babelrc 文件 1234&#123; "presets": ["@babel/preset-env", "@babel/preset-react"], "plugins": ["@babel/plugin-transform-runtime"]&#125; 按需引入 polyfill在 src 下的 index.js 中全局引入@babel/polyfill 并写入 es6 语法，但是这样有一个缺点:全局引入@babel/polyfill 的这种方式可能会导入代码中不需要的 polyfill，从而使打包体积更大，修改.babelrc 配置 1234567891011121314`yarn add core-js@2 @babel/runtime-corejs2 --dev`&#123; "presets": [ [ "@babel/preset-env", &#123; "useBuiltIns": "usage" &#125; ], "@babel/preset-react" ], "plugins": ["@babel/plugin-transform-runtime"]&#125; 这就配置好了按需引入。配置了按需引入 polyfill 后，用到 es6 以上的函数，babel 会自动导入相关的 polyfill，这样能大大减少打包编译后的体积。 babel-runtime 和 babel-polyfill 的区别 参考https://www.jianshu.com/p/73ba084795ce babel-polyfill 会”加载整个 polyfill 库”，针对编译的代码中新的 API 进行处理，并且在代码中插入一些帮助函数 babel-polyfill 解决了 Babel 不转换新 API 的问题，但是直接在代码中插入帮助函数，会导致污染了全局环境，并且不同的代码文件中包含重复的代码，导致编译后的代码体积变大。 Babel 为了解决这个问题，提供了单独的包 babel-runtime 用以提供编译模块的工具函数， 启用插件 babel-plugin-transform-runtime 后，Babel 就会使用 babel-runtime 下的工具函数 babel-runtime 适合在组件，类库项目中使用，而 babel-polyfill 适合在业务项目中使用。 高级概念tree shaking(js) tree shaking 可清除代码中无用的 js 代码，只支持 import 方式引入，不支持 commonjs 的方式引入mode 是 production 的无需配置，下面的配置是针对 development 的 12345678// webpack.config.jsoptimization: &#123; usedExports: true&#125;// package.json"sideEffects": false, Code Spliting 代码分割，和 webpack 无关 同步代码(需在 webpack.config.js 中配置 optimization) 1234567891011// index.jsimport _ from 'lodash';console.log(_.join(['a','b','c'], '****'))// 在webpack.base.js里做相关配置optimization: &#123; splitChunks: &#123; chunks: 'all' &#125; &#125;, 异步代码(无需任何配置，但需安装@babel/plugin-syntax-dynamic-import包) 123456789101112// index.jsfunction getComponent() &#123; return import("lodash").then((&#123; default: _ &#125;) =&gt; &#123; const element = document.createElement("div"); element.innerHTML = _.join(["Jack", "Cool"], "-"); return element; &#125;);&#125;getComponent().then(el =&gt; &#123; document.body.appendChild(el);&#125;); Caching(缓存) 通过使用 output.filename 进行文件名替换，可以确保浏览器获取到修改后的文件。[hash] 替换可以用于在文件名中包含一个构建相关(build-specific)的 hash，但是更好的方式是使用 [contenthash] 替换，当文件内容发生变化时，[contenthash]也会发生变化 1234output: &#123; filename: "[name].[contenthash].js", chunkFilename: '[name].[contenthash].chunk.js'&#125; Shimming webpack 编译器(compiler)能够识别遵循 ES2015 模块语法、CommonJS 或 AMD 规范编写的模块。然而，一些第三方的库(library)可能会引用一些全局依赖（例如 jQuery 中的 \$）。这些库也可能创建一些需要被导出的全局变量。这些“不符合规范的模块”就是 shimming 发挥作用的地方 shimming 全局变量(第三方库)(ProvidePlugin 相当于一个垫片) 12345678910111213141516 const path = require('path');+ const webpack = require('webpack'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist')- &#125;+ &#125;,+ plugins: [+ new webpack.ProvidePlugin(&#123;+ _: 'lodash'+ &#125;)+ ] &#125;; 细粒度 shimming(this 指向 window)(需要安装 imports-loader 依赖) 1234567891011121314151617181920212223 const path = require('path'); const webpack = require('webpack'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;,+ module: &#123;+ rules: [+ &#123;+ test: require.resolve('index.js'),+ use: 'imports-loader?this=&gt;window'+ &#125;+ ]+ &#125;, plugins: [ new webpack.ProvidePlugin(&#123; join: ['lodash', 'join'] &#125;) ] &#125;; 环境变量 webpack 命令行环境选项 –env 允许您传入任意数量的环境变量。您的环境变量将可访问 webpack.config.js。例如，–env.production 或–env.NODE_ENV=local 1webpack --env.NODE_ENV=local --env.production --progress 使用环境变量必须对 webpack 配置进行一项更改。通常，module.exports 指向配置对象。要使用该 env 变量，必须转换 module.exports 为函数： 12345678910111213141516// webpack.config.jsconst path = require("path");module.exports = env =&gt; &#123; // Use env.&lt;YOUR VARIABLE&gt; here: console.log("NODE_ENV: ", env.NODE_ENV); // 'local' console.log("Production: ", env.production); // true return &#123; entry: "./src/index.js", output: &#123; filename: "bundle.js", path: path.resolve(__dirname, "dist") &#125; &#125;;&#125;; library 打包配置 除了打包应用程序代码，webpack 还可以用于打包 JavaScript library用户应该能够通过以下方式访问 library: ES2015 模块。例如 import library from ‘library’ CommonJS 模块。例如 require(‘library’) 全局变量，当通过 script 脚本引入时 我们打包的 library 中可能会用到一些第三方库，诸如 lodash。现在，如果执行 webpack，你会发现创建了一个非常巨大的文件。如果你查看这个文件，会看到 lodash 也被打包到代码中。在这种场景中，我们更倾向于把 lodash 当作 peerDependency。也就是说，用户应该已经将 lodash 安装好。因此，你可以放弃对外部 library 的控制，而是将控制权让给使用 library 的用户。这可以使用 externals 配置来完成： 12345678910111213141516171819 // webpack.config.js var path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'webpack-numbers.js'- &#125;+ &#125;,+ externals: &#123;+ lodash: &#123;+ commonjs: 'lodash',+ commonjs2: 'lodash',+ amd: 'lodash',+ root: '_'+ &#125;+ &#125; &#125;; 对于用途广泛的 library，我们希望它能够兼容不同的环境，例如 CommonJS，AMD，Node.js 或者作为一个全局变量。为了让你的 library 能够在各种用户环境(consumption)中可用，需要在 output 中添加 library 属性： 1234567891011121314151617181920 // webpack.config.js var path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'),- filename: 'library.js'+ filename: 'library.js',+ library: 'library' &#125;, externals: &#123; lodash: &#123; commonjs: 'lodash', commonjs2: 'lodash', amd: 'lodash', root: '_' &#125; &#125; &#125;; 当你在 import 引入模块时，这可以将你的 library bundle 暴露为名为 webpackNumbers 的全局变量。为了让 library 和其他环境兼容，还需要在配置文件中添加 libraryTarget 属性。这是可以控制 library 如何以不同方式暴露的选项。 12345678910111213141516171819 var path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'library.js',+ library: 'library',+ libraryTarget: 'umd' &#125;, externals: &#123; lodash: &#123; commonjs: 'lodash', commonjs2: 'lodash', amd: 'lodash', root: '_' &#125; &#125; &#125;; 我们还需要通过设置 package.json 中的 main 字段，添加生成 bundle 的文件路径。 123456// package.json&#123; ... "main": "dist/library.js", ...&#125; PWA 打包配置 渐进式网络应用程序(Progressive Web Application - PWA)，是一种可以提供类似于原生应用程序(native app)体验的网络应用程序(web app)。PWA 可以用来做很多事。其中最重要的是，在离线(offline)时应用程序能够继续运行功能。这是通过使用名为 Service Workers 的网络技术来实现的添加 workbox-webpack-plugin 插件，并调整 webpack.config.js 文件： 1npm install workbox-webpack-plugin --save-dev webpack.config.js 1234567891011121314151617181920212223242526272829 const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin');+ const WorkboxPlugin = require('workbox-webpack-plugin'); module.exports = &#123; entry: &#123; app: './src/index.js', print: './src/print.js' &#125;, plugins: [ new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin(&#123;- title: 'Output Management'+ title: 'Progressive Web Application'- &#125;)+ &#125;),+ new WorkboxPlugin.GenerateSW(&#123;+ // 这些选项帮助 ServiceWorkers 快速启用+ // 不允许遗留任何“旧的” ServiceWorkers+ clientsClaim: true,+ skipWaiting: true+ &#125;) ], output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist') &#125; &#125;; 注册 Service Worker 123456789101112 import _ from 'lodash'; import printMe from './print.js';+ if ('serviceWorker' in navigator) &#123;+ window.addEventListener('load', () =&gt; &#123;+ navigator.serviceWorker.register('/sw.js').then(registration =&gt; &#123;+ console.log('SW registered: ', registration);+ &#125;).catch(registrationError =&gt; &#123;+ console.log('SW registration failed: ', registrationError);+ &#125;);+ &#125;);+ &#125; 现在来进行测试。停止服务器并刷新页面。如果浏览器能够支持 Service Worker，你应该可以看到你的应用程序还在正常运行。然而，服务器已经停止了服务，此刻是 Service Worker 在提供服务。 TypeScript 打包配置 可参考https://www.webpackjs.com/guides/typescript/或https://webpack.js.org/guides/typescript/ 安装 ts 依赖npm install --save-dev typescript ts-loader 增加 tsconfig.json 配置文件 12345678910&#123; "compilerOptions": &#123; "outDir": "./dist/", "noImplicitAny": true, "module": "es6", "target": "es5", "jsx": "react", "allowJs": true &#125;&#125; webpack.config.js 添加对 ts/tsx 语法支持(ts-loader) 123456789101112131415161718192021const path = require("path");module.exports = &#123; entry: "./src/index.ts", module: &#123; rules: [ &#123; test: /\.tsx?$/, use: "ts-loader", exclude: /node_modules/ &#125; ] &#125;, resolve: &#123; extensions: [".tsx", ".ts", ".js"] &#125;, output: &#123; filename: "bundle.js", path: path.resolve(__dirname, "dist") &#125;&#125;; 当从 npm 安装第三方库时，一定要牢记同时安装这个库的类型声明文件。可以从 TypeSearch 中找到并安装这些第三方库的类型声明文件。如npm install --save-dev @types/lodash webpack 性能优化 及时更新 node、yarn、webpack 等的版本 在尽可能少的模块上应用 loader plugin 尽可能精简并确保可靠(选用社区已验证的插件) resolve 参数合理配置(具体参考https://www.webpackjs.com/configuration/resolve/) 使用 DllPlugin 提高打包速度 控制包文件大小(tree shaking / splitChunksPlugin) thread-loader,parallel-webpack,happypack 多进程打包 合理利用 sourceMap 结合stats.json分析打包结果(bundle analyze) 开发环境内存编译 开发环境无用插件剔除]]></content>
      <categories>
        <category>web工程化</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native开发过程梳理]]></title>
    <url>%2F2019%2F08%2F04%2Freact-native%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[之前在用 rn 开发跨平台应用时，仅是开发环境配置（运行基础的 hello world），就耗费了我大量的时间，今天整理一下，希望给打算入 rn 神坑的小伙伴一个指引（我已弃坑，准备去搞 flutter 了）。以下是 windows 平台的，mac 平台请绕路。。 环境配置 配置可参考https://reactnative.cn/docs/0.40/getting-started.html https://reactnative.cn/docs/getting-started.html https://facebook.github.io/react-native/docs/getting-started 1、下载Chocolatey(windows 包管理器)，用于安装python2、jdk8、node。安装方式 1@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin jdk 安装与环境变量配置: https://jingyan.baidu.com/article/6dad5075d1dc40a123e36ea3.html 2、设置 npm 镜像 12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global 3、安装 React Native 的命令行工具（react-native-cli） 1npm install -g react-native-cli 4、 android studio 安装(下载地址: https://developer.android.google.cn/)安装界面中选择“custom”选项，确保选中了以下几项: Android SDK Android SDK Platform Performance (Intel ® HAXM) Android Virtual Device 5、ANDROID_HOME 环境变量配置 6、将 Android SDK 的 Tools 目录添加到 PATH 变量中可以把 Android SDK 的 tools 和 platform-tools 目录添加到 PATH 变量中，以便在终端中运行一些 Android 工具 7、创建新项目使用 React Native 命令行工具来创建一个名为”AwesomeProject”的新项目： 1react-native init AwesomeProject --version 0.55.4 8、下载夜神模拟器模拟器相关配置可参考https://www.cnblogs.com/piaobodewu/p/9786513.html 启动模拟器 cmd 进入夜神模拟器安装目录的 bin 目录下D:\Program Files\Nox\bin执行nox_adb devices，然后应该就有模拟器的名字了，一般都是 127.0.0.1:62001 cmd 进去 android 的 SDK 的 platform-tools 目录下D:\android_sdk\platform-tools执行命令adb.exe connect 127.0.0.1:62001连接模拟器 进入项目根目录将项目打包安装到模拟器react-native run-android 9、启动项目(项目根目录打包安装到模拟器) 1react-native run-android 初始化项目运行可能会遇见的问题 真机红屏报错: https://www.cnblogs.com/piaobodewu/p/9889460.html 创建工程 gradle-2.4-all 包下载问题: https://blog.csdn.net/u010411264/article/details/53636956]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue路由动态权限控制]]></title>
    <url>%2F2019%2F08%2F04%2Fvue%E8%B7%AF%E7%94%B1%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前一段时间公司做了一个 oa 系统，涉及到菜单权限相关的。经过调研（又称 google），发现 vue2.2.0 之后添加的 addRoutes 功能甚是好用。整个过程踩了很多坑，因此简单整理了以下。 具体实现 创建 vue 实例的时候将 vue-router 挂载，但这个时候 vue-router 挂载一些登录或者不用权限的公用的页面 当用户登录后，获取用户角色 role，将 role 和路由表的每个页面需要的权限作比较，生成最终用户可访问的路由表 调用 router.addRoutes(store.getters.addRouters)添加用户可访问的路由 使用 vuex 管理路由表，根据 vuex 中可访问的路由渲染侧边栏组件 router.js 通过vue-router官方的 meta 标签来标示该页面能访问的权限有哪些。比如meta: { role: [&#39;admin&#39;,&#39;ceo&#39;] }表示该页面只有 admin 和 ceo 才有进入的权限。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// router.jsimport Vue from 'vue';import VueRouter from "vue-router";Vue.use(VueRouter);import Login from '@/views/login'//所有权限通用路由表//如首页和登录页和一些不用权限的公用页面export const constantRouterMap = [ &#123; path: '/login', component: Login &#125;,]//异步挂载的路由//动态需要根据权限加载的路由表export const asyncRouterMap = [ &#123; path: "/achievements", name: "achievements", component: achievements, children: [ &#123; path: "employeeAchievements", name: "employeeAchievements", component: () =&gt; import("@/views/achievements/components/employeeAchievements"), meta: &#123; roles: ["ceo"] &#125; &#125;, &#123; path: "departmentAchievements", name: "departmentAchievements", component: () =&gt; import("@/views/achievements/components/departmentAchievements"), meta: &#123; roles: ["department_head"] &#125; &#125;, &#123; path: "subordinateAchievements", name: "subordinateAchievements", component: () =&gt; import("@/views/achievements/components/subordinateAchievements"), meta: &#123; roles: ["direct_supervisor", "project_manger", "general_manager"] &#125; &#125;, &#123; path: "strategyAchievements", name: "strategyAchievements", component: () =&gt; import("@/views/achievements/components/strategyAchievements"), meta: &#123; roles: ["ceo"] &#125; &#125;, &#123; path: "personalAchievements", name: "personalAchievements", component: () =&gt; import("@/views/achievements/components/personalAchievements"), meta: &#123; roles: ["employee"] &#125; &#125;, &#123; path: "projectAchievements", name: "projectAchievements", component: () =&gt; import("@/views/achievements/components/projectAchievements"), meta: &#123; roles: ["project_manger", "general_manager"] &#125; &#125; ] &#125;, &#123; path: "*", redirect: "/achievements" &#125;];// 实例化vue的时候只挂载constantRouterMapconst createRouter = () =&gt; new VueRouter(&#123; scrollBehavior: () =&gt; (&#123; y: 0 &#125;), routes： constantRouterMap&#125;)// 通过addRoutes动态添加的路由，如何动态删除（用户权限变化或用户登出）// 参考`https://juejin.im/post/5c92ff94f265da6128275a85#heading-4` `https://github.com/vuejs/vue-router/issues/1234#issuecomment-357941465`const router = createRouter()export function resetRouter() &#123; const newRouter = createRouter() router.matcher = newRouter.matcher&#125;export default router main.js 在vue-router的全局前置守卫router.beforeEach中获取用户对应权限信息，并用 addRoutes 动态添加可访问路由表 123456789101112131415161718192021222324252627282930313233343536373839404142// main.jsimport Vue from "vue";import router from "@/router";import App from "./App.vue";import store from "@/store";import iView from "iview";Vue.use(iView);router.beforeEach(async (to, from, next) =&gt; &#123; // to and from are both route objects. must call `next`. const hasRoles = store.state.user.roles &amp;&amp; store.state.user.roles.length &gt; 0; // 判断是否有用户角色信息 if (hasRoles) &#123; // 有用户权限信息，说明所有可访问路由已生成，如访问没权限页面会自动进入404页面 next(); &#125; else &#123; // 没有用户权限信息，先拉取用户信息 try &#123; const roles = await store.dispatch("user/getInfo"); // 获取到用户权限信息 // eslint-disable-next-line const accessRoutes = await store.dispatch( // 生成可访问的路由表 "permission/generateRoutes", roles ); router.addRoutes(accessRoutes); // 动态添加可访问路由表 if (to.name === "/") &#123; next(&#123; name: "home", replace: true &#125;); &#125; else &#123; next(&#123; ...to, replace: true &#125;); // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record &#125; &#125; catch (err) &#123; console.log(err); &#125; &#125;&#125;);router.afterEach((to, from, next) =&gt; &#123; iView.LoadingBar.finish(); window.scrollTo(0, 0);&#125;); store/permission.js 通过用户的权限和之前在 router.js 里面 asyncRouterMap 的每一个页面所需要的权限做匹配，最后返回一个该用户能够访问路由有哪些 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// store/permission.jsimport &#123; constantRouterMap, asyncRouterMap &#125; from "@/router"; // 引入静态路由和动态路由function hasPermission(roles, route) &#123; // 遍历判断是否有进入该页面的权限 if (route.meta &amp;&amp; route.meta.roles) &#123; return roles.some(role =&gt; route.meta.roles.includes(role)); &#125; return true;&#125;function deepCopy(source) &#123; // 深拷贝 if (!source) &#123; return source; &#125; let sourceCopy = source instanceof Array ? [] : &#123;&#125;; for (let item in source) &#123; sourceCopy[item] = typeof source[item] === "object" ? deepCopy(source[item]) : source[item]; &#125; return sourceCopy;&#125;export function filterAsyncRoutes(routes, roles) &#123; // 过滤生成可访问路由表 const res = []; routes.forEach(route =&gt; &#123; const tmp = &#123; ...route &#125;; if (hasPermission(roles, tmp)) &#123; if (tmp.children) &#123; tmp.children = filterAsyncRoutes(tmp.children, roles); &#125; res.push(tmp); &#125; &#125;); return res;&#125;export default &#123; namespaced: true, state: &#123; routes: deepCopy(constantRouterMap), addRoutes: [] &#125;, getters: &#123;&#125;, mutations: &#123; SET_ROUTES: (state, routes) =&gt; &#123; state.addRoutes = routes; state.routes = deepCopy(constantRouterMap.concat(routes)); &#125; &#125;, actions: &#123; generateRoutes(&#123; commit &#125;, roles) &#123; return new Promise(resolve =&gt; &#123; let accessedRoutes = filterAsyncRoutes(asyncRouterMap, roles); commit("SET_ROUTES", deepCopy(accessedRoutes)); resolve(accessedRoutes); &#125;); &#125; &#125;&#125;; store/user.js 获取用户对应的 role 之前，需要先拿到 token。详细流程如下： 登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个 token，拿到 token 之后（我会将这个 token 存贮到 cookie 中，保证刷新页面后能记住用户登录状态），前端会根据 token 再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。 权限验证：通过 token 获取用户对应的 role，动态根据用户的 role 算出其对应有权限的路由，通过 router.addRoutes 动态挂载这些路由。 123456789101112131415161718192021222324252627export default &#123; namespaced: true, state: &#123; token: "", isHr: true, roles: [] &#125;, getters: &#123;&#125;, mutations: &#123; SET_TOKEN: (state, token) =&gt; &#123; state.token = token; &#125;, SET_ROLES: (state, roles) =&gt; &#123; state.roles = roles; &#125; &#125;, actions: &#123; getInfo(&#123; commit, state &#125;) &#123; // 获取用户信息接口，拿到服务端返回的token、用户名、用户权限等信息 return new Promise((resolve, reject) =&gt; &#123; const rolesFromSeivice = ["ceo"]; // 从接口拿到的用户权限信息（用户角色） commit("SET_ROLES", rolesFromSeivice); resolve(rolesFromSeivice); &#125;); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流年博客的Hello World]]></title>
    <url>%2F2019%2F01%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[你好，我是流年，进阶全栈的路上···]]></content>
  </entry>
</search>
